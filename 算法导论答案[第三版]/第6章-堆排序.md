## 练习

[x]:表示不大于x的最大整数；【x】：表示不小于x的最小整数

**6.1-1 在高度为h的堆中，元素个数最多和最少分别是多少？**

**6.1-2 证明：含n个元素的堆的高度为$[lgn]$**

**6.1-3 证明：在最大堆的任一子树中，该子树所包含的最大元素在该子树的根节点上。**

**6.1-4 假设一个最大堆的所有元素都不相同，那么该堆的最小元素应该位于哪里？**

**6.1-5 一个已排好续的数组是一个最小堆么？**

**6.1-6 值为<23,17,14,6,13,10,1,5,7,12>的数组是一个最大堆么？**

**6.1-7 证明：当用数组表示存储n个元素的堆时，叶节点下表分别是$[n/2]+1,[n/2]+2,...,n$.**

**6.2-1参照图6-2的方法，说明MAX-HEAPIFY(A,3)在数组A=<27,17,3,16,13,10,1,5,7,12,4,8,9,0>上的操作过程**

**6.2-2 参考过程MAX-HEAPIFRY，写出能够维护相应最小堆的MIN-HEAPIFY(A,i)的伪代码，并比较MIN-HEAPIFY与MAX-HEAPIFY的运行时间。**

**6.2-3 当元素A[i]比其孩子的值都大时，调用MAX-HEAPIFY(A,i)会有什么结果？**

**6.2-4 当i>A.heap-size/2时，调用MAX-HEAPIFY(A,i)会有什么结果？**

**6.2-5 MAX-HEAPIFY的代码效率较高，但第10行的递归调用可能例外，它可能使某些编译器产生低效率的代码。请用循环控制结构取代递归，重写MAX-HEAPIFY代码。**

**6.2-6 证明：对一个大小为n的堆，MAX-HEAPIFY的最坏情况运行时间为Ω(lgn)。（提示：对于n个节点的堆，可以通过对每个结点设定恰当的值，使得从根节点到叶节点路径上的每个节点都会递归调用MAX-HEAPIFY。）**

**6.3-1 参照图6-3的方法，说明BUILD-MAX-HEAP在数组A=<5,3,17,10,84,19,6,22,9>上的操作过程。**

**6.3-2 对于BUILD-MAX-HEAP中第2行的循环控制变量i来说，为什么我们要求它是从[A.length/2]到1递减，而不是从1到[A.length/2]递增呢？**

**6.3-3 证明：对于任一包含n个元素的堆中，至多有【$n/2^{h+1}$】个高度为h的节点?**

**6.4-1 参照图6-4的方法，说明HEAPSORT在数组A=<5,13,2,25,7,17,20,8,4>上的操作过程**

**6.4-2 试分析在使用下列循环变量时，HEAPSORT的正确性：**

​                  在算法的第2~5行for循环每次迭代开始时，子数组A[1..i]是一个包含了数组A[1..n]中第i小元素的最大			堆，而子数组A[i+1..n]包含了数组A[1..n]中已排序的n-i个最大元素？

**6.4-3 对于一个按升序排列的n个元素的有序数组A来说，HEAPSORT的时间复杂度是多少？如果A是降序的呢？**

**6.4-4 证明：在最坏情况下，HEAPSORT的时间复杂度是Ω(n lgn)**.

***6.4-5 证明： 在所有元素都不同的情况下，HEAPSORT的时间复杂度是Ω(n logn).**

**6.5-1 试说明HEAP-EXTRACT-MAX在堆A=<15,13,9,5,12,8,7,4,0,6,2,1>上的操作过程**

**6.5-2 试说明MAX-HEAP-INSERT(A,10)在堆A=<15,13,9,5,12,8,7,4,0,6,2,1>上的操作过程**

**6.5-3 要求用最小堆实现最小优先队列，请写出HEAP-MINIMUM、HEAP-EXTRACT-MIN、HEAP-DECREASE-KEY 和MIN-HEAP-INSERT的伪代码。**

**6.5-4 在MAX-HEAP-INSERT的第2行，为什么我们要先把关键字设为-∞，然后又将其增加到所需的值呢？**

**6.5-5 试分析在使用下列循环不变量时，HEAP-INCREASE-KEY的正确性：**

​				在算法的第4~6行while循环每次迭代开始的时候，子数组A[1..A.heap-size]要满足最大堆的性质。如果有违背，只有一个可能：A[i]大于A[PARENT(i)].

**6.5-6 在HEAP-INCREASE-KEY的第5行的交换操作中，一般需要通过三次赋值来完成。想一想如何利用INSERTION-SORT内循环部分的思想，只用一次赋值就完成这一交换操作？**

**6.5-7 试说明如何使用优先队列来实现一系列先进先出队列，以及如何使用优先队列来实现栈。**

**6.5-8 HEAP-DELETE(A,i)操作能够将节点i从堆A中删除。对于一个包含n个元素的堆，请设计一个能够在O(lgn)时间内完成HEAP-DELETE操作。**

**6.5-9 请设计一个时间复杂度为O(n lgk)的算法，它能够将k个有序链表合并为一个有序链表，这里n是所有输入链表包含的总元素个数。（提示：使用最小堆来完成k路归并。）**



## 思考题

6-1

6-2

6-3



















